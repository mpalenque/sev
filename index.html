<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Skin Smoothing with MediaPipe ImageSegmenter</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    background-color: #131313; /* Updated */
    background-image: url('sev.png');
    background-size: cover; /* Optional: to make the image cover the entire background */
    background-repeat: no-repeat; /* Optional: to prevent the image from repeating */
    background-position: center center; /* Optional: to center the image */
  }
  #liveViewContainer {
    position: relative;
    border: 1px solid #2b2b2b; /* Updated */
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    background-color: transparent; /* Ensure this is transparent */
    padding: 10px;
    border-radius: 8px;
  }
  video {
    display: none; /* Hide video element, we'll draw to canvas */
  }
  canvas {
    display: block;
    border: 1px solid #2b2b2b; /* Updated */
  }
  .controls {
    margin-top: 15px;
    padding: 15px;
    background-color: #1f1f1f; /* Updated */
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  .controls button {
    padding: 10px 15px;
    font-size: 16px;
    cursor: pointer;
    border: none;
    border-radius: 5px;
    background-color: #a48353; /* Updated */
    color: #ffffff; /* Updated */
    margin-bottom: 10px;
  }
  .controls button:hover {
    background-color: #8c6f47; /* Darker shade of #a48353 for hover */
  }
  .controls label {
    margin-bottom: 5px;
    color: #ffffff; /* Updated */
  }
  .controls input[type="range"] {
    width: 200px;
    accent-color: #a48353; /* Updated */
  }
  #loadingMessage {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 1.2em;
    color: #131313; /* Updated */
    background-color: rgba(255, 255, 255, 0.9); /* Updated for better readability */
    padding: 10px;
    border-radius: 5px;
    display: none; /* Hidden by default */
  }
</style>
</head>
<body>
  

  <div id="liveViewContainer">
    <video id="webcam" autoplay playsinline></video>
    <canvas id="output_canvas" width="640" height="480"></canvas>
    <div id="loadingMessage">Loading model and webcam...</div>
  </div>

  <div class="controls">
    <button id="webcamButton">ENABLE WEBCAM</button>
    <button id="takePhotoButton" style="margin-top: 10px;">TAKE PHOTO</button>
    <label for="blurSlider">Blur Amount:</label>
    <input type="range" id="blurSlider" min="0" max="1" step="0.01" value="0.8">
  </div>

  <script type="module">
    import vision from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3"; // Changed import style
    const { ImageSegmenter, FaceLandmarker, FilesetResolver } = vision; // Destructure necessary components

    // Stack Blur implementation for iOS compatibility
    // Based on StackBlur.js by Mario Klingemann
    function stackBlurCanvasRGBA(canvas, top_x, top_y, width, height, radius) {
      if (isNaN(radius) || radius < 1) return;
      
      const context = canvas.getContext("2d");
      const imageData = context.getImageData(top_x, top_y, width, height);
      const pixels = imageData.data;
      
      let x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, 
          r_out_sum, g_out_sum, b_out_sum, a_out_sum,
          r_in_sum, g_in_sum, b_in_sum, a_in_sum, 
          pr, pg, pb, pa, rbs;
          
      const div = radius + radius + 1;
      const w4 = width << 2;
      const widthMinus1 = width - 1;
      const heightMinus1 = height - 1;
      const radiusPlus1 = radius + 1;
      const sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
      
      const stackStart = new BlurStack();
      let stack = stackStart;
      let stackEnd;
      for (i = 1; i < div; i++) {
          stack = stack.next = new BlurStack();
          if (i === radiusPlus1) stackEnd = stack;
      }
      stack.next = stackStart;
      let stackIn = null;
      let stackOut = null;
      
      yw = yi = 0;
      
      const mul_sum = mul_table[radius];
      const shg_sum = shg_table[radius];
      
      for (y = 0; y < height; y++) {
          r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;
          
          r_out_sum = radiusPlus1 * (pr = pixels[yi]);
          g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
          b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
          a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
          
          r_sum += sumFactor * pr;
          g_sum += sumFactor * pg;
          b_sum += sumFactor * pb;
          a_sum += sumFactor * pa;
          
          stack = stackStart;
          
          for (i = 0; i < radiusPlus1; i++) {
              stack.r = pr;
              stack.g = pg;
              stack.b = pb;
              stack.a = pa;
              stack = stack.next;
          }
          
          for (i = 1; i < radiusPlus1; i++) {
              p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
              r_sum += (stack.r = (pr = pixels[p])) * (rbs = radiusPlus1 - i);
              g_sum += (stack.g = (pg = pixels[p + 1])) * rbs;
              b_sum += (stack.b = (pb = pixels[p + 2])) * rbs;
              a_sum += (stack.a = (pa = pixels[p + 3])) * rbs;
              
              r_in_sum += pr;
              g_in_sum += pg;
              b_in_sum += pb;
              a_in_sum += pa;
              
              stack = stack.next;
          }
          
          stackIn = stackStart;
          stackOut = stackEnd;
          for (x = 0; x < width; x++) {
              pixels[yi + 3] = pa = (a_sum * mul_sum) >> shg_sum;
              if (pa !== 0) {
                  pa = 255 / pa;
                  pixels[yi] = ((r_sum * mul_sum) >> shg_sum) * pa;
                  pixels[yi + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;
                  pixels[yi + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;
              } else {
                  pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
              }
              
              r_sum -= r_out_sum;
              g_sum -= g_out_sum;
              b_sum -= b_out_sum;
              a_sum -= a_out_sum;
              
              r_out_sum -= stackIn.r;
              g_out_sum -= stackIn.g;
              b_out_sum -= stackIn.b;
              a_out_sum -= stackIn.a;
              
              p = (yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1)) << 2;
              
              r_in_sum += (stackIn.r = pixels[p]);
              g_in_sum += (stackIn.g = pixels[p + 1]);
              b_in_sum += (stackIn.b = pixels[p + 2]);
              a_in_sum += (stackIn.a = pixels[p + 3]);
              
              r_sum += r_in_sum;
              g_sum += g_in_sum;
              b_sum += b_in_sum;
              a_sum += a_in_sum;
              
              stackIn = stackIn.next;
              
              r_out_sum += (pr = stackOut.r);
              g_out_sum += (pg = stackOut.g);
              b_out_sum += (pb = stackOut.b);
              a_out_sum += (pa = stackOut.a);
              
              r_in_sum -= pr;
              g_in_sum -= pg;
              b_in_sum -= pb;
              a_in_sum -= pa;
              
              stackOut = stackOut.next;
              
              yi += 4;
          }
          yw += width;
      }
      
      for (x = 0; x < width; x++) {
          g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;
          
          yi = x << 2;
          r_out_sum = radiusPlus1 * (pr = pixels[yi]);
          g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
          b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
          a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
          
          r_sum += sumFactor * pr;
          g_sum += sumFactor * pg;
          b_sum += sumFactor * pb;
          a_sum += sumFactor * pa;
          
          stack = stackStart;
          
          for (i = 0; i < radiusPlus1; i++) {
              stack.r = pr;
              stack.g = pg;
              stack.b = pb;
              stack.a = pa;
              stack = stack.next;
          }
          
          yp = width;
          
          for (i = 1; i <= radius; i++) {
              yi = (yp + x) << 2;
              
              r_sum += (stack.r = (pr = pixels[yi])) * (rbs = radiusPlus1 - i);
              g_sum += (stack.g = (pg = pixels[yi + 1])) * rbs;
              b_sum += (stack.b = (pb = pixels[yi + 2])) * rbs;
              a_sum += (stack.a = (pa = pixels[yi + 3])) * rbs;
              
              r_in_sum += pr;
              g_in_sum += pg;
              b_in_sum += pb;
              a_in_sum += pa;
              
              stack = stack.next;
              
              if (i < heightMinus1) {
                  yp += width;
              }
          }
          
          yi = x;
          stackIn = stackStart;
          stackOut = stackEnd;
          for (y = 0; y < height; y++) {
              p = yi << 2;
              pixels[p + 3] = pa = (a_sum * mul_sum) >> shg_sum;
              if (pa > 0) {
                  pa = 255 / pa;
                  pixels[p] = ((r_sum * mul_sum) >> shg_sum) * pa;
                  pixels[p + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;
                  pixels[p + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;
              } else {
                  pixels[p] = pixels[p + 1] = pixels[p + 2] = 0;
              }
              
              r_sum -= r_out_sum;
              g_sum -= g_out_sum;
              b_sum -= b_out_sum;
              a_sum -= a_out_sum;
              
              r_out_sum -= stackIn.r;
              g_out_sum -= stackIn.g;
              b_out_sum -= stackIn.b;
              a_out_sum -= stackIn.a;
              
              p = (x + (((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width)) << 2;
              
              r_sum += (r_in_sum += (stackIn.r = pixels[p]));
              g_sum += (g_in_sum += (stackIn.g = pixels[p + 1]));
              b_sum += (b_in_sum += (stackIn.b = pixels[p + 2]));
              a_sum += (a_in_sum += (stackIn.a = pixels[p + 3]));
              
              stackIn = stackIn.next;
              
              r_out_sum += (pr = stackOut.r);
              g_out_sum += (pg = stackOut.g);
              b_out_sum += (pb = stackOut.b);
              a_out_sum += (pa = stackOut.a);
              
              r_in_sum -= pr;
              g_in_sum -= pg;
              b_in_sum -= pb;
              a_in_sum -= pa;
              
              stackOut = stackOut.next;
              
              yi += width;
          }
      }
      
      context.putImageData(imageData, top_x, top_y);
    }

    function BlurStack() {
      this.r = 0;
      this.g = 0;
      this.b = 0;
      this.a = 0;
      this.next = null;
    }

    // Stack blur calculation tables
    const mul_table = [
      512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,
      454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,
      482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,
      437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,
      497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,
      320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,
      446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,
      329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,
      505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,
      399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,
      324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,
      268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,
      451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,
      385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,
      332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,
      289,287,285,282,280,278,275,273,271,269,267,265,263,261,259];
      
    const shg_table = [
      9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 
      17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 
      19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
      20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
      21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
      21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 
      22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
      22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 
      23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
      23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
      23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
      23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24 ];

    // Detectando si es iOS para usar técnicas alternativas
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    console.log("Dispositivo iOS detectado:", isIOS);

    let imageSegmenter;
    let faceLandmarker;
    let runningMode = "VIDEO";
    const video = document.getElementById("webcam");
    const canvasElement = document.getElementById("output_canvas");
    const canvasCtx = canvasElement.getContext("2d", { alpha: true });
    const webcamButton = document.getElementById("webcamButton");
    const loadingMessage = document.getElementById("loadingMessage");
    const takePhotoButton = document.getElementById("takePhotoButton");
    const blurSlider = document.getElementById("blurSlider");

    const blurScaleFactor = 0.5; 
    const landmarkMaskScaleFactor = 0.5; 
    const landmarkMaskBlurRadius = 3; 
    const SLIDER_POWER_CURVE = 3; 
    const RAW_SLIDER_DEFAULT_VALUE = 0.8;
    const SLIDER_MAX_VALUE = 20;

    function calculateEffectiveBlur(rawValue, sliderMax, power) {
      if (sliderMax === 0) return 0; 
      const normalizedValue = rawValue / sliderMax;
      return Math.pow(normalizedValue, power) * sliderMax;
    }

    // Initial blurAmount set by the slider's default value
    let blurAmount = calculateEffectiveBlur(parseFloat(blurSlider.value), 1, SLIDER_POWER_CURVE) * SLIDER_MAX_VALUE;

    const blurredVideoCanvas = document.createElement("canvas");
    const blurredVideoCtx = blurredVideoCanvas.getContext("2d", { alpha: true, willReadFrequently: true });
    const maskCanvas = document.createElement("canvas");
    const maskCanvasCtx = maskCanvas.getContext("2d", { alpha: true, willReadFrequently: true });
    const effectLayerCanvas = document.createElement("canvas");
    const effectLayerCtx = effectLayerCanvas.getContext("2d", { alpha: true, willReadFrequently: true });

    const eyeMaskCanvas = document.createElement("canvas");
    const eyeMaskCtx = eyeMaskCanvas.getContext("2d", { alpha: true, willReadFrequently: true });

    const faceOvalMaskCanvas = document.createElement("canvas");
    const faceOvalMaskCtx = faceOvalMaskCanvas.getContext("2d", { alpha: true, willReadFrequently: true });

    let tempBlurLayerCanvas = document.createElement('canvas');
    let tempBlurLayerCtx = tempBlurLayerCanvas.getContext('2d', {willReadFrequently: true, alpha: true});

    const personMaskCanvas = document.createElement("canvas");
    const personMaskCtx = personMaskCanvas.getContext("2d", { alpha: true, willReadFrequently: true });
    const personOnlyCanvas = document.createElement("canvas");
    const personOnlyCtx = personOnlyCanvas.getContext("2d", { alpha: true, willReadFrequently: true });

    const skinCategoryIndices = [3];
    const personCategoryIndices = [1, 2, 3];

    // ... el resto de funciones se mantienen igual ...

    async function createMediaPipeTasks() {
      // ...código existente...
    }

    async function enableCam() {
      // ...código existente...
    }
    webcamButton.addEventListener("click", enableCam);
    takePhotoButton.addEventListener("click", handleTakePhotoClick);

    blurSlider.addEventListener("input", (event) => {
      const rawValue = parseFloat(event.target.value); // Slider value is 0 to 1
      blurAmount = calculateEffectiveBlur(rawValue, 1, SLIDER_POWER_CURVE) * SLIDER_MAX_VALUE;
      console.log(`Blur slider changed. Raw: ${rawValue}, Calculated blurAmount: ${blurAmount}`);
    });

    async function dataURLtoBlob(dataurl) {
      const res = await fetch(dataurl);
      return await res.blob();
    }

    async function handleTakePhotoClick() {
      // ...código existente...
    }

    function drawMaskFromPixelData(maskPixelData, maskWidth, maskHeight, targetCtx, targetIndices) {
      // ...código existente...
    }

    let lastVideoTime = -1;
    let isPredicting = false;

    async function predictWebcam() {
      console.log(`[predictWebcam START] isPredicting: ${isPredicting}, video.paused: ${video.paused}, video.ended: ${video.ended}, video.readyState: ${video.readyState}, blurAmount: ${blurAmount}`);

      if (!isPredicting || !video.srcObject || video.paused || video.ended) {
        isPredicting = false;
        console.log("[predictWebcam] Loop stopping: initial check failed (not predicting, no src, paused, or ended).");
        return;
      }

      if (video.readyState < video.HAVE_ENOUGH_DATA || !imageSegmenter || !faceLandmarker) {
          console.log(`[predictWebcam] Video not ready (readyState ${video.readyState}) or models not loaded. Retrying next frame.`);
          if (isPredicting) requestAnimationFrame(predictWebcam);
          return;
      }

      let startTimeMs = performance.now();
      let segmentationResultsToClose = null;

      if (video.currentTime !== lastVideoTime) {
        lastVideoTime = video.currentTime;
        
        const segmentationResults = imageSegmenter.segmentForVideo(video, startTimeMs);
        if (segmentationResults && segmentationResults.categoryMask) {
            segmentationResultsToClose = segmentationResults.categoryMask;
        }
        console.log("Segmentation results:", segmentationResults);
        const landmarkResults = faceLandmarker.detectForVideo(video, startTimeMs);
        console.log("Landmark results:", landmarkResults);

        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

        let personDrawnSuccessfully = false;
        if (segmentationResults && segmentationResults.categoryMask) {
          const fullMask = segmentationResults.categoryMask;
          const fullMaskPixelData = fullMask.getAsUint8Array();
          const fullMaskWidth = fullMask.width;
          const fullMaskHeight = fullMask.height;

          if (fullMaskPixelData && fullMaskWidth > 0 && fullMaskHeight > 0) {
            if (personMaskCanvas.width !== fullMaskWidth || personMaskCanvas.height !== fullMaskHeight) {
              personMaskCanvas.width = fullMaskWidth;
              personMaskCanvas.height = fullMaskHeight;
            }
            drawMaskFromPixelData(fullMaskPixelData, fullMaskWidth, fullMaskHeight, personMaskCtx, personCategoryIndices);

            personOnlyCtx.clearRect(0, 0, personOnlyCanvas.width, personOnlyCanvas.height);
            personOnlyCtx.drawImage(video, 0, 0, personOnlyCanvas.width, personOnlyCanvas.height);
            personOnlyCtx.globalCompositeOperation = 'destination-in';
            personOnlyCtx.drawImage(personMaskCanvas, 0, 0, personOnlyCanvas.width, personOnlyCanvas.height);
            personOnlyCtx.globalCompositeOperation = 'source-over';

            canvasCtx.drawImage(personOnlyCanvas, 0, 0, canvasElement.width, canvasElement.height);
            personDrawnSuccessfully = true;
          }
        }

        if (!personDrawnSuccessfully) {
          console.warn("[predictWebcam] Person segmentation failed or no mask. Drawing raw video.");
          canvasCtx.drawImage(video, 0, 0, canvasElement.width, canvasElement.height);
        }

        if (segmentationResults && segmentationResults.categoryMask && landmarkResults && landmarkResults.faceLandmarks && landmarkResults.faceLandmarks.length > 0) {
          console.log("CategoryMask available for smoothing:", !!segmentationResults.categoryMask);
          console.log("FaceLandmarks available for smoothing:", landmarkResults.faceLandmarks.length);
          const skinMaskForSmoothing = segmentationResults.categoryMask;
          const skinMaskPixelData = skinMaskForSmoothing.getAsUint8Array();
          const skinMaskWidth = skinMaskForSmoothing.width;
          const skinMaskHeight = skinMaskForSmoothing.height;
          const landmarks = landmarkResults.faceLandmarks[0];
          console.log(`Skin mask dimensions for smoothing: ${skinMaskWidth}x${skinMaskHeight}. Pixel data length: ${skinMaskPixelData ? skinMaskPixelData.length : 'null'}`);

          if (skinMaskPixelData && skinMaskWidth > 0 && skinMaskHeight > 0) {
            // Draw video un-blurred onto the smaller blurredVideoCanvas (it now acts as a source)
            blurredVideoCtx.clearRect(0, 0, blurredVideoCanvas.width, blurredVideoCanvas.height);
            blurredVideoCtx.drawImage(video, 0, 0, blurredVideoCanvas.width, blurredVideoCanvas.height);

            if (maskCanvas.width !== skinMaskWidth || maskCanvas.height !== skinMaskHeight) {
                maskCanvas.width = skinMaskWidth;
                maskCanvas.height = skinMaskHeight;
            }
            drawMaskFromPixelData(skinMaskPixelData, skinMaskWidth, skinMaskHeight, maskCanvasCtx, skinCategoryIndices);

            eyeMaskCtx.clearRect(0, 0, eyeMaskCanvas.width, eyeMaskCanvas.height);
            eyeMaskCtx.fillStyle = 'white';
            
            // Función para dibujar polígonos de landmarks
            function drawLandmarkPolygon(landmarkConnections, targetCtx, targetCanvas) {
              if (landmarks && landmarkConnections && landmarkConnections.length > 0) {
                targetCtx.beginPath();
                const firstLandmarkIndex = landmarkConnections[0].start;
                if (landmarks[firstLandmarkIndex]) {
                  const firstPoint = landmarks[firstLandmarkIndex];
                  targetCtx.moveTo(firstPoint.x * targetCanvas.width, firstPoint.y * targetCanvas.height);
                  for (const conn of landmarkConnections) {
                    const endLandmarkIndex = conn.end;
                    if (landmarks[endLandmarkIndex]) {
                      const endPoint = landmarks[endLandmarkIndex];
                      targetCtx.lineTo(endPoint.x * targetCanvas.width, endPoint.y * targetCanvas.height);
                    } else {
                      console.warn(`Landmark index ${endLandmarkIndex} not found.`);
                    }
                  }
                  targetCtx.closePath();
                  targetCtx.fill();
                } else {
                  console.warn(`Landmark index ${firstLandmarkIndex} not found for starting point.`);
                }
              }
            }

            function drawCustomLandmarkPolygonFromIndices(vertexIndices, targetCtx, targetCanvas) {
              if (landmarks && vertexIndices && vertexIndices.length > 0) {
                targetCtx.beginPath();
                const firstLandmarkIndex = vertexIndices[0];
                if (landmarks[firstLandmarkIndex]) {
                  const firstPoint = landmarks[firstLandmarkIndex];
                  targetCtx.moveTo(firstPoint.x * targetCanvas.width, firstPoint.y * targetCanvas.height);
                  for (let i = 1; i < vertexIndices.length; i++) {
                    const landmarkIndex = vertexIndices[i];
                    if (landmarks[landmarkIndex]) {
                      const point = landmarks[landmarkIndex];
                      targetCtx.lineTo(point.x * targetCanvas.width, point.y * targetCanvas.height);
                    } else {
                      console.warn(`Landmark index ${landmarkIndex} not found in custom list.`);
                    }
                  }
                  targetCtx.closePath();
                  targetCtx.fill();
                } else {
                  console.warn(`Landmark index ${firstLandmarkIndex} not found for starting point in custom list.`);
                }
              }
            }

            function drawTriangleOnMask(vertexIndices, targetCtx, targetCanvas) {
              if (landmarks && vertexIndices && vertexIndices.length === 3) {
                const points = vertexIndices.map(index => landmarks[index]);
                if (points.every(p => p)) {
                  targetCtx.beginPath();
                  targetCtx.moveTo(points[0].x * targetCanvas.width, points[0].y * targetCanvas.height);
                  targetCtx.lineTo(points[1].x * targetCanvas.width, points[1].y * targetCanvas.height);
                  targetCtx.lineTo(points[2].x * targetCanvas.width, points[2].y * targetCanvas.height);
                  targetCtx.closePath();
                  targetCtx.fill();
                } else {
                  console.warn(`Invalid landmark index in triangle: ${vertexIndices}`);
                }
              }
            }

            // Si estamos en iOS, usamos un desenfoque menor para las áreas de contorno
            const iOSLandmarkMaskBlurRadius = isIOS ? 1 : landmarkMaskBlurRadius;
            
            if (iOSLandmarkMaskBlurRadius > 0 && !isIOS) {
                eyeMaskCtx.filter = `blur(${iOSLandmarkMaskBlurRadius}px)`;
            }

            drawLandmarkPolygon(FaceLandmarker.FACE_LANDMARKS_LEFT_EYE, eyeMaskCtx, eyeMaskCanvas);
            drawLandmarkPolygon(FaceLandmarker.FACE_LANDMARKS_RIGHT_EYE, eyeMaskCtx, eyeMaskCanvas);
            drawLandmarkPolygon(FaceLandmarker.FACE_LANDMARKS_LEFT_EYEBROW, eyeMaskCtx, eyeMaskCanvas);
            drawLandmarkPolygon(FaceLandmarker.FACE_LANDMARKS_RIGHT_EYEBROW, eyeMaskCtx, eyeMaskCanvas);
            drawLandmarkPolygon(FaceLandmarker.FACE_LANDMARKS_LIPS, eyeMaskCtx, eyeMaskCanvas);

            const innerMouthTriangles = [
              [78, 95, 88], [78, 178, 87], [95, 178, 96],
              [78, 88, 87], [88, 87, 178], [88, 95, 96],
              [96, 88, 178]
            ];
            innerMouthTriangles.forEach(triangle => drawTriangleOnMask(triangle, eyeMaskCtx, eyeMaskCanvas));
            drawTriangleOnMask([185, 292, 61], eyeMaskCtx, eyeMaskCanvas);
            const specificEyebrowTriangles = [
              [107, 55, 65], [63, 46, 52],
              [336, 285, 295], [293, 276, 334]
            ];
            specificEyebrowTriangles.forEach(triangle => drawTriangleOnMask(triangle, eyeMaskCtx, eyeMaskCanvas));

            const additionalEyeVertices = [7,22,23,24,25,26,27,28,29,30,33,56,110,112,130,133,144,145,153,154,155,157,158,159,160,161,163,173,190,243,246,247];
            drawCustomLandmarkPolygonFromIndices(additionalEyeVertices, eyeMaskCtx, eyeMaskCanvas);

            const additionalOtherEyeVertices = [249,252,253,254,255,256,257,258,259,260,263,286,339,341,359,362,373,374,380,381,382,384,385,386,387,388,390,398,414,463,466,467];
            drawCustomLandmarkPolygonFromIndices(additionalOtherEyeVertices, eyeMaskCtx, eyeMaskCanvas);

            if (iOSLandmarkMaskBlurRadius > 0 && !isIOS) {
                eyeMaskCtx.filter = 'none';
            } else if (isIOS && iOSLandmarkMaskBlurRadius > 0) {
                // Para iOS, aplicamos StackBlur en lugar del filtro CSS
                stackBlurCanvasRGBA(eyeMaskCanvas, 0, 0, eyeMaskCanvas.width, eyeMaskCanvas.height, iOSLandmarkMaskBlurRadius);
            }

            faceOvalMaskCtx.clearRect(0, 0, faceOvalMaskCanvas.width, faceOvalMaskCanvas.height);
            faceOvalMaskCtx.fillStyle = 'white';
            
            if (iOSLandmarkMaskBlurRadius > 0 && !isIOS) {
                faceOvalMaskCtx.filter = `blur(${iOSLandmarkMaskBlurRadius}px)`;
            }

            drawLandmarkPolygon(FaceLandmarker.FACE_LANDMARKS_FACE_OVAL, faceOvalMaskCtx, faceOvalMaskCanvas);
            
            if (iOSLandmarkMaskBlurRadius > 0 && !isIOS) {
                faceOvalMaskCtx.filter = 'none';
            } else if (isIOS && iOSLandmarkMaskBlurRadius > 0) {
                // Para iOS, aplicamos StackBlur en lugar del filtro CSS
                stackBlurCanvasRGBA(faceOvalMaskCanvas, 0, 0, faceOvalMaskCanvas.width, faceOvalMaskCanvas.height, iOSLandmarkMaskBlurRadius);
            }

            effectLayerCtx.clearRect(0, 0, effectLayerCanvas.width, effectLayerCanvas.height);
            effectLayerCtx.drawImage(maskCanvas, 0, 0, effectLayerCanvas.width, effectLayerCanvas.height);
            
            effectLayerCtx.globalCompositeOperation = 'destination-in';
            effectLayerCtx.drawImage(faceOvalMaskCanvas, 0, 0, effectLayerCanvas.width, effectLayerCanvas.height);
            
            effectLayerCtx.globalCompositeOperation = 'destination-out';
            effectLayerCtx.drawImage(eyeMaskCanvas, 0, 0, effectLayerCanvas.width, effectLayerCanvas.height);
            
            effectLayerCtx.globalCompositeOperation = 'source-over';

            tempBlurLayerCtx.clearRect(0, 0, tempBlurLayerCanvas.width, tempBlurLayerCanvas.height);
            tempBlurLayerCtx.drawImage(blurredVideoCanvas, 0, 0, tempBlurLayerCanvas.width, tempBlurLayerCanvas.height);

            // Aplicar desenfoque utilizando la técnica apropiada según el dispositivo
            if (isIOS) {
                // Para iOS usamos StackBlur en vez del filtro CSS
                if (blurAmount > 0) {
                    // Ajustamos el radio para iOS (puede que necesites experimentar con esta escala)
                    const iosBlurRadius = Math.max(1, Math.min(40, Math.floor(blurAmount * 0.7)));
                    console.log(`Applying iOS blur with radius: ${iosBlurRadius}`);
                    stackBlurCanvasRGBA(tempBlurLayerCanvas, 0, 0, tempBlurLayerCanvas.width, tempBlurLayerCanvas.height, iosBlurRadius);
                }
            } else {
                // Para otros dispositivos usamos el filtro CSS
                if (blurAmount > 0) {
                    console.log(`Applying standard blur with amount: ${blurAmount}px`);
                    const backupCanvas = document.createElement('canvas');
                    backupCanvas.width = tempBlurLayerCanvas.width;
                    backupCanvas.height = tempBlurLayerCanvas.height;
                    const backupCtx = backupCanvas.getContext('2d');
                    backupCtx.drawImage(tempBlurLayerCanvas, 0, 0);
                    
                    tempBlurLayerCtx.filter = `blur(${blurAmount}px)`;
                    tempBlurLayerCtx.clearRect(0, 0, tempBlurLayerCanvas.width, tempBlurLayerCanvas.height);
                    tempBlurLayerCtx.drawImage(backupCanvas, 0, 0);
                    tempBlurLayerCtx.filter = 'none';
                }
            }

            // Aplicar la máscara al layer con desenfoque
            tempBlurLayerCtx.globalCompositeOperation = 'destination-in';
            tempBlurLayerCtx.drawImage(effectLayerCanvas, 0, 0, tempBlurLayerCanvas.width, tempBlurLayerCanvas.height);
            tempBlurLayerCtx.globalCompositeOperation = 'source-over';

            // Dibujar el resultado final en el canvas de salida
            canvasCtx.drawImage(tempBlurLayerCanvas, 0, 0, canvasElement.width, canvasElement.height);

          } else {
            console.warn("[predictWebcam] Skin mask data for smoothing was invalid or dimensions were zero. Skipping smoothing effect.");
          }
        } else {
            console.warn("[predictWebcam] No valid segmentation mask OR no landmarks found for this frame. Skipping smoothing effect.");
        }
      }
      
      if(segmentationResultsToClose){
        try {
            segmentationResultsToClose.close();
        } catch(e){
            console.warn("Error closing categoryMask:", e);
        }
      }

      if (isPredicting) {
        window.requestAnimationFrame(predictWebcam);
      } else {
        console.log("[predictWebcam END] Not predicting, loop will stop.");
      }
    }
  </script>
</body>
</html>
